<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Quickstart Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="introduction/ecosystem.html"><strong aria-hidden="true">1.2.</strong> Ecosystem</a></li><li class="chapter-item expanded "><a href="introduction/ide-setup.html"><strong aria-hidden="true">1.3.</strong> IDE Setup</a></li></ol></li><li class="chapter-item expanded "><a href="basic-syntax.html"><strong aria-hidden="true">2.</strong> Basic Syntax</a></li><li class="chapter-item expanded "><a href="project-structure.html"><strong aria-hidden="true">3.</strong> Project Structure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="multiple-binaries.html"><strong aria-hidden="true">3.1.</strong> Multiple Binaries</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">3.2.</strong> Unit Testing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Quickstart Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is meant to serve as a rapid introduction to the rust programming language.
It is geared towards developers that are already fairly experienced with programming in other languages.
Specifically, experience in C/C++ or something similar is recommended.</p>
<p>We will not waste time with concepts such as pointers, loops, structs, etc.
Instead, we will dive right into rust syntax/idioms and talk about how it is different from other languages.</p>
<p>This book will contain many examples and is written based on the concept of &quot;show, don't tell&quot;.
There are also quiz questions throughout to encourage the reader to think deeper or experiment with code.</p>
<p>There will likely be some mistakes and typos.
Please reach out if any are spotted.</p>
<h3 id="authors"><a class="header" href="#authors">Authors</a></h3>
<ul>
<li>Chuck Rai</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The officially supported way to install rust is through <a href="https://www.rust-lang.org/tools/install">rustup</a>.
This should also install all necessary build dependencies.
On Windows, Visual Studio C++ Build Tools may also be required.</p>
<p>Once installed, we should have the following command line utilities:</p>
<ul>
<li><code>rustup</code> is a utility to manage rust compiler installations.</li>
<li><code>rustc</code> is the rust compiler and linker. The rust compiler is based on llvm.</li>
<li><code>rustdoc</code> is a documentation generation tool.</li>
<li><code>rustfmt</code> is an opinionated code formatting tool to settle formatting arguments.</li>
<li><code>cargo</code> is a build tool to manage projects and dependencies.</li>
</ul>
<p>We should also get the following debuggers:</p>
<ul>
<li><code>rust-gdb</code></li>
<li><code>rust-lldb</code></li>
</ul>
<p>We should not need to interface with <code>rustc</code> directly if we are using <code>cargo</code> to build and run our projects.</p>
<p>These tools are extensively documented:</p>
<ul>
<li><a href="https://rust-lang.github.io/rustup/">rustup book</a></li>
<li><a href="https://doc.rust-lang.org/stable/rustc/">rustc book</a></li>
<li><a href="https://doc.rust-lang.org/stable/rustdoc/">rustdoc book</a></li>
<li><a href="https://rust-lang.github.io/rustfmt/">rustfmt docs</a></li>
<li><a href="https://doc.rust-lang.org/stable/cargo/">cargo book</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ecosystem"><a class="header" href="#ecosystem">Ecosystem</a></h1>
<p>Third partly libraries in rust are referred to as crates.
When we create our own project, it is also referred to as a crate.
Our crate can have dependencies on other crates.
We can find crates made by other users at <a href="https://crates.io/">https://crates.io/</a>.</p>
<p>When using <code>cargo</code> to manage our project, it will automatically download and compile any crate dependencies.</p>
<p>The rust ecosystem favours crates that are MIT/APACHE dual licensed.</p>
<p>One of the strong points of rust is the expansive ecosystem of high quality crates made by other users.</p>
<h3 id="official-logo"><a class="header" href="#official-logo">Official logo</a></h3>
<p><img src="https://github.com/rust-lang/rust-artwork/raw/master/logo/rust-logo-128x128.png" alt="" /></p>
<h3 id="mascot"><a class="header" href="#mascot">Mascot</a></h3>
<p>This is Ferris, the unofficial rust mascot.</p>
<p><img src="https://www.rust-lang.org/static/images/ferris.gif" alt="" /></p>
<p>Rust fanatics might sometimes call themselves &quot;Rustaceans&quot;.
If this word comes up, it is a good sign to walk away rapidly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jetbrains"><a class="header" href="#jetbrains">JetBrains</a></h1>
<p>IntelliJ IDEA Ultimate and CLion are both good options for rust development.
IntelliJ IDEA Community Edition is free while the other two are not.
However, the paid tools support debugging while the free one does not.</p>
<p>Plugins:</p>
<ul>
<li><a href="https://plugins.jetbrains.com/bundles/3-rust-bundle">Rust bundle</a></li>
</ul>
<h1 id="vscode"><a class="header" href="#vscode">VSCode</a></h1>
<p>Plugins:</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">Rust</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">LLDB</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=JScearcy.rust-doc-viewer">Documentation Viewer</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates">Crate Management</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=belfz.search-crates-io">Crate Search</a></li>
<li><a href="https://marketplace.visualstudio.com/search?term=rust&amp;target=VSCode">Many others that look great</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a comment
/* This is a
    multiline comment */
<span class="boring">}
</span></code></pre></pre>
<h1 id="basic-types"><a class="header" href="#basic-types">Basic types</a></h1>
<table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>u32</code></td><td>Unsigned 32 bit integer. Also have <code>u8</code>, <code>u16</code>, <code>u64</code>, and <code>u128</code>. When an architecture is unable to support an integer width, it will be emulated in software.</td></tr>
<tr><td><code>i32</code></td><td>Signed 32 bit integer. Also have <code>i8</code>, <code>i16</code>, <code>i64</code>, and <code>i128</code>.</td></tr>
<tr><td><code>usize</code></td><td>Unsigned integer that is atleast large enough to hold a memory address. Also have <code>isize</code> for signed. <code>usize</code> is commonly used as the size type of container classes such as <code>Vec</code>.</td></tr>
<tr><td><code>f32</code></td><td>32 bit floating point number. Also have <code>f64</code>.</td></tr>
<tr><td><code>bool</code></td><td>Boolean value.</td></tr>
<tr><td><code>char</code></td><td>32 bit Unicode Scalar Value used to hold a single character. This is enough bits to store any Unicode character in a single <code>char</code>.</td></tr>
</tbody></table>
<p>These types come with many useful constant values such as: <code>f32::NAN</code>, <code>std::f32::consts::PI</code>, <code>u32::MAX</code>, etc.</p>
<p>Notice that there is no empty type such as <code>null</code>, <code>nil</code>, <code>undefined</code>, <code>void</code>, or <code>None</code> like we might see in other languages.
In rust, similar behaviour can be achieved using the <code>Option&lt;&gt;</code> type which we will see later.</p>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Arguments a and b both have type u32
// Return type is also u32
fn add(a: u32, b: u32) -&gt; u32 {
    // Statements must end with a semicolon ;
    return a + b;
}

// Functions could return nothing
// This is the C/C++ equivalent of a void return type
fn foo(a: bool) {
    // Code goes here
}

// There is a special return type called &quot;never&quot; for functions that never return
fn start_web_server() -&gt; ! {
    // Loop forever
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn if_else(a: u32, b: u32) -&gt; u32 {
    // No need to put parentheses () around the conditional
    if a &lt; b {
        return b - a;
    }
    else if b &lt; a {
        return a - b;
    }
    else {
        return a - b;
    }
}

// TODO: talk about match expressions
<span class="boring">}
</span></code></pre></pre>
<h1 id="variables-and-literals"><a class="header" href="#variables-and-literals">Variables and literals</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn variables(a: u32, b: u32) -&gt; u32 {
    // It is not possible to create a variable without assigning a value to it
    let sum: u32 = a + b;

    // All variables are immutable by default
    // Use the &quot;mut&quot; keyword to create mutable variables
    let mut x: u32 = 12;
    x = 83;

    // Types can omitted if the compiler is able to figure it out based on context
    let product = a * b;

    return sum;
}

fn literals() -&gt; f32 {
    // char literals should be surrounded by single quotes ''
    let heart_eyed_cat: char = 'ðŸ˜»';
    let pile_of_poo: char = '\u{1F4A9}';

    let boolean_value: bool = true;
    let other_boolean_value: bool = false;

    // Literals have built in type annotation
    let integer_value: u16 = 15u16;
    let other_integer_value: i64 = -54i64;
    let float_value: f64 = 23.532f64;

    // This is another case where types can be omitted
    let omit_variable_type = 43u32;
    let omit_literal_type: u32 = 43;

    // Literals can contain underscores _ for readability
    let one_million = 1_000_000_u32;

    let usize_value = 27_usize;
    let isize_value = -14_isize;
    let float_32_pi = 3.14159_f32;
    let float_32_accurate_pi = std::f32::consts::PI;
    let float_64_nan = f64::NAN;
    let u32_max_value = u32::MAX;

    // Ways to specify integers
    let decimal = 23_u32;
    let hex = 0x_fa_42_u16;
    let octal = 0o_72_u8;
    let binary = 0b_1111_0000_u8;

    let dense_hex: u16 = 0xfa42;
    let dense_octal: u8 = 0o72;
    let dense_binary: u8 = 0b11110000;

    // The float type here can be inferred through the function return type
    return 2.71828;
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust is a statically typed language so all variables must have a type that can be determined at compile time.
However, the compiler is quite clever which often lets us omit types.
There are some ambiguous scenarios where the compiler may choose a default type without raising a warning.
Best practice is to always be as explicit as possible.</p>
<h3 id="quiz"><a class="header" href="#quiz">Quiz</a></h3>
<p>Does the following statement result in a sign extension?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let octal = 0o_72_i8;
<span class="boring">}
</span></code></pre></pre>
<h1 id="blocks-and-scopes"><a class="header" href="#blocks-and-scopes">Blocks and scopes</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Functions bodies create a new scope
fn nesting(a: u32, b: u32) -&gt; u32 {
    // A new scope can be created anywhere by using curly braces {}
    {
        // Variables from the outer scope can be accessed in the inner scope
        let scoped_variable = a + b;
    }
    // scoped_variable is not visible outside of its enclosing block

    // Functions can also be confined to a scope
    fn triple(a: u32) -&gt; u32 {
        return a * 3;
    }

    // The &quot;return&quot; keyword can be omitted if it is the last statement in the block
    // To do this, we also omit the semicolon ;
    fn quadruple(a: u32) -&gt; u32 {
        let double = a * a;

        double * double
    }

    triple(4) + quadruple(5)
}

fn shadowing() {
    // Rust allows variables to be redefined within the same scope
    // The redefined variable can even have a different type
    // This is called &quot;shadowing&quot;
    let x: u32 = 17;
    let x: bool = true;
    {
        // Within nested scopes, it is also called &quot;shadowing&quot;
        // This type of shadowing should be more familiar from other languages
        let x: f32 = 5.5;
    }
    // Be careful with shadowing because it can easily lead to errors
    // The compiler will not warn you about shadowed variable names

    // This can help in keeping variable names from getting ugly
    // It also helps avoid having mutable variables as often as possible
    let input = get_user_input();
    let input = parse_integer(input);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="quiz-1"><a class="header" href="#quiz-1">Quiz</a></h3>
<p>Come back to this one after learning about references.</p>
<p>What will be the result of this code?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 17;
let x_ref: &amp;u32 = &amp;x;

let x: bool = false;

print!(&quot;{}&quot;, *x_ref);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-project"><a class="header" href="#creating-a-project">Creating a project</a></h1>
<p>Use <code>cargo new</code> to start a new project:</p>
<pre><code class="language-shell">cargo new demo-project
</code></pre>
<p>This will create a new directory named <code>demo-project</code> with the following files:</p>
<pre><code>.git/&lt;git-stuff&gt;  &lt;- Cargo automatically initializes a git repository for us
.gitignore
Cargo.toml        &lt;- Cargo.toml contains project metadata used by the build system
src/
    main.rs       &lt;- Project source code
</code></pre>
<p>The filename <code>main.rs</code> is important because we are creating a bin project.
Alternatively, we could create a lib project:</p>
<pre><code class="language-shell">cargo new --lib demo-project
</code></pre>
<p>This generates:</p>
<pre><code>.git/&lt;git-stuff&gt;
.gitignore
Cargo.toml
src/
    lib.rs
</code></pre>
<p>Bin projects are the default for <code>cargo new</code> but the following command is also valid:</p>
<pre><code class="language-shell">cargo new --bin demo-project
</code></pre>
<p>Bin projects produce executable binaries while lib projects produce libraries to be used by other projects.
We will ignore lib projects for now.</p>
<h1 id="boilerplate-files"><a class="header" href="#boilerplate-files">Boilerplate files</a></h1>
<p>Let's have a closer look at these generated files.</p>
<h2 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = &quot;demo-project&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p><code>package.name</code> and <code>package.version</code> are both required keys. <code>package.edition</code> tells cargo which rust edition to use.
The rust <a href="https://doc.rust-lang.org/stable/edition-guide/">edition</a> is not the same thing as the rust version.
For example, code that is written for edition 2021 could interoperate seamlessly with code that is written for edition
2018 as long as we use a rust version that supports at least edition 2021.</p>
<p>Under dependencies, we can specify external libraries that we would like to use.
These external libraries are called crates.
The cargo registry can be used to look up available crates at <a href="https://crates.io/">https://crates.io/</a>.
Our own project would also be referred to as a crate.</p>
<h2 id="srcmainrs"><a class="header" href="#srcmainrs">src/main.rs</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Like with a C/C++ project, rust expects a <code>main()</code> function which will used as the entry point of the program.
It is possible to compile without a main function or without the rust standard library for bare metal programming.</p>
<p><code>println!()</code> is a macro which will print to stdout. We will talk more about macros later.</p>
<h1 id="build-and-run"><a class="header" href="#build-and-run">Build and run</a></h1>
<p>Use <code>cargo build</code> to compile:</p>
<pre><code class="language-shell">cargo build
cargo build --debug          # &lt;- Default behaviour
cargo build --release
</code></pre>
<p>This will produce a <code>target/</code> directory with the following binaries:</p>
<pre><code>./target/debug/demo-project
./target/release/demo-project
</code></pre>
<p>When we build our crate, cargo generates a <code>Cargo.lock</code> file. This file contains information about the build such as the
versions and checksums of external crates that were downloaded and compiled into our program.
This file is useful if we want to ensure reproducible builds.</p>
<p>Use <code>cargo run</code> to both compile and then run:</p>
<pre><code class="language-shell">cargo run
cargo run --debug            # &lt;- Default behaviour
cargo run --release
</code></pre>
<p>Use <code>cargo clean</code> to delete the <code>target/</code> directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-binaries"><a class="header" href="#multiple-binaries">Multiple binaries</a></h1>
<p>By default, cargo expects to find a <code>main.rs</code> file with an entry point that it can use to create a binary.
Instead, we could create a project with multiple binaries:</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<pre><code>Cargo.toml
src/
    client.rs
    server.rs

examples/
    hello_world_example.rs

target/        &lt;- Compiled binaries found here
    debug/
        client
        server
        examples/
            hello_world_example
</code></pre>
<h2 id="cargotoml-1"><a class="header" href="#cargotoml-1">Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = &quot;multiple-binaries&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[[bin]]
name = &quot;client&quot;
path = &quot;src/client.rs&quot;

[[bin]]
name = &quot;server&quot;
path = &quot;src/server.rs&quot;
</code></pre>
<h2 id="srcclientrs"><a class="header" href="#srcclientrs">src/client.rs</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;I am a client.&quot;);
}
</code></pre></pre>
<h2 id="srcserverrs"><a class="header" href="#srcserverrs">src/server.rs</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;I am a server.&quot;);
}
</code></pre></pre>
<h2 id="exampleshello_world_examplers"><a class="header" href="#exampleshello_world_examplers">examples/hello_world_example.rs</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;I am an example.&quot;);
}
</code></pre></pre>
<p>Use <code>cargo run</code> with the <code>--bin</code> or <code>--example</code> arguments to specify which binary to run:</p>
<pre><code class="language-shell">cargo run --bin client
cargo run --bin server
cargo run --example hello_world_example
</code></pre>
<p>The <code>examples/</code> directory is a special location where we can place code samples for users to run with demo data.
For example, if we were creating a graphics renderer we could include some demo scenes as examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-testing"><a class="header" href="#unit-testing">Unit testing</a></h1>
<p>The easiest way to do unit testing is to create functions marked with the <code>#[test]</code> macro.
We can do this anywhere within the crate.</p>
<p>We haven't talked about function syntax yet but for now we will use the following add function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a: u32, b: u32) -&gt; u32 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>A unit test looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_add() {
    assert_eq!(add(7, 12), 19);
    assert_ne!(add(8, 8), 0);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>#[test]</code>, <code>assert_eq!()</code>, and <code>assert_ne!()</code> are all macros.</p>
<h2 id="srcmainrs-1"><a class="header" href="#srcmainrs-1">src/main.rs</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}

fn add(a: u32, b: u32) -&gt; u32 {
    a + b
}

#[test]
fn test_add_0() {
    assert_eq!(add(7, 12), 19);
}

#[test]
fn test_add_1() {
    assert_eq!(add(23, 56), 79);
}

#[test]
fn test_add_2() {
    assert_ne!(add(2, 2), 5);
}
</code></pre></pre>
<p>Use <code>cargo test</code> to run all unit tests:</p>
<pre><code>$ cargo test
   Compiling unit-testing v0.1.0 (/tmp/unit-testing)
    Finished test [unoptimized + debuginfo] target(s) in 0.31s
     Running unittests (target/debug/deps/unit_testing-e0254e70a2565982)

running 3 tests
test test_add_0 ... ok
test test_add_1 ... ok
test test_add_2 ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>There is no guarantee on the order in which tests will be run.</p>
<h1 id="running-a-subset-of-tests"><a class="header" href="#running-a-subset-of-tests">Running a subset of tests</a></h1>
<p>We can run only a specific test by its name:</p>
<pre><code class="language-shell">cargo test test_add_1
</code></pre>
<p>We can also specify a range of tests:</p>
<pre><code class="language-shell">cargo test test_add_
</code></pre>
<p>This will run all tests which contain the substring <code>test_add_</code>.</p>
<h1 id="tests-module"><a class="header" href="#tests-module">Tests module</a></h1>
<p>Rust convention is to have unit tests in the same file as the code that is being tested but in a submodule.
Having it in the same file makes it more convenient to update the tests when updating the code.
Having it in a submodule avoids namespace pollution from all the test functions being created.</p>
<h2 id="srcmainrs-2"><a class="header" href="#srcmainrs-2">src/main.rs</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}

fn add(a: u32, b: u32) -&gt; u32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::add;

    #[test]
    fn test_add_0() {
        assert_eq!(add(7, 12), 19);
    }

    #[test]
    fn test_add_1() {
        assert_eq!(add(23, 56), 79);
    }

    #[test]
    fn test_add_2() {
        assert_ne!(add(2, 2), 5);
    }
}
</code></pre></pre>
<ul>
<li><code>mod tests { ... }</code> creates a submodule called tests.</li>
<li><code>use super::add;</code> imports the <code>add()</code> function from the containing module.</li>
<li><code>#[cfg(test)]</code> tells cargo to only compile this code when running <code>cargo test</code> and not in a normal build.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
